name: Build, Package and Release

on:
  push:
    branches: [main]
  pull_request:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 2.0.1)'
        required: true
      deploy_ppa:
        description: 'Deploy to PPA?'
        required: true
        default: true
        type: boolean

env:
  DEBEMAIL: safarikikandi@gmail.com
  DEBFULLNAME: NetSnmp Enterprise

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        distro: [ubuntu-20.04, ubuntu-22.04]
    
    steps:
    - uses: actions/checkout@v3
    - name: Setup
      run: sudo apt-get update && sudo apt-get install -y make
    - name: Build
      run: make
    - name: Test
      run: make test

  package-deb:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    - name: Build Debian package using Docker
      uses: docker://debian:bullseye
      with:
        args: sh -c "apt-get update && apt-get install -y make debhelper devscripts && cd /github/workspace && make deb"
    - name: Upload Debian package
      uses: actions/upload-artifact@v4
      with:
        name: deb-package
        path: "*.deb"

  package-source-deb:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Get current version
      id: get_version
      run: |
        # Try to get version from changelog or use default
        if [ -f "packaging/deb/debian/changelog" ]; then
          VERSION=$(head -1 packaging/deb/debian/changelog | awk '{print $2}' | tr -d '()' | cut -d- -f1)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        else
          echo "VERSION=2.0.0" >> $GITHUB_OUTPUT
        fi
        echo "Current version: $VERSION"
    
    - name: Prepare source package directory
      run: |
        mkdir -p source-packages
        # Create orig tarball
        cd packaging/deb
        mkdir -p ../..
        tar czf ../../netsnmp-enterprise_${{ steps.get_version.outputs.VERSION }}.orig.tar.gz .
    
    - name: Fix changelog format
      run: |
        cd packaging/deb/debian
        # Replace $(date -R) with actual date
        CURRENT_DATE=$(date -R)
        # Create proper changelog format
        cat > changelog << EOF
            netsnmp-enterprise (${{ steps.get_version.outputs.VERSION }}-1) unstable; urgency=medium

              * Automated build from GitHub Actions

            -- ${{ env.DEBFULLNAME }} <${{ env.DEBEMAIL }}>  $CURRENT_DATE
            EOF
    
    - name: Build Debian source package
      uses: docker://debian:bullseye
      env:
        DEBEMAIL: ${{ env.DEBEMAIL }}
        DEBFULLNAME: ${{ env.DEBFULLNAME }}
      with:
        args: |
          sh -c "
          apt-get update && 
          apt-get install -y make debhelper devscripts build-essential && 
          cd /github/workspace/packaging/deb && 
          # Build source package with proper orig tarball
          debuild -S -sa -us -uc
          "
    
    - name: Collect source package artifacts
      run: |
        cd /github/workspace
        # Copy all source package files
        cp -f *.dsc *.tar.* *_source.changes source-packages/ 2>/dev/null || true
        # List what we found
        echo "Source package files:"
        ls -la source-packages/
    
    - name: Upload Debian source package
      uses: actions/upload-artifact@v4
      with:
        name: deb-source-package
        path: source-packages/*

  determine-version:
    runs-on: ubuntu-latest
    needs: [package-deb, package-source-deb]
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
      is_release: ${{ steps.version.outputs.IS_RELEASE }}
    steps:
    - name: Download source artifacts to get version info
      uses: actions/download-artifact@v4
      with:
        name: deb-source-package
        path: downloaded-source
        
    - name: Determine version and type
      id: version
      run: |
        if [ "${{ github.event_name }}" = "release" ] && [ -n "${{ github.event.release.tag_name }}" ]; then
          # For GitHub releases, use the tag name (remove 'v' prefix)
          VERSION="${{ github.event.release.tag_name }}"
          VERSION="${VERSION#v}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "IS_RELEASE=true" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual dispatch, use the input version
          VERSION="${{ github.event.inputs.version }}"
          # Clean up version input
          VERSION=$(echo "$VERSION" | sed 's/^v//')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "IS_RELEASE=true" >> $GITHUB_OUTPUT
        else
          # Auto-increment patch version for main branch pushes
          if ls downloaded-source/*.dsc 1> /dev/null 2>&1; then
            LATEST_DSC=$(ls downloaded-source/*.dsc | head -1)
            BASE_VERSION=$(basename "$LATEST_DSC" | cut -d_ -f2)
            MAJOR=$(echo $BASE_VERSION | cut -d. -f1)
            MINOR=$(echo $BASE_VERSION | cut -d. -f2)
            PATCH=$(echo $BASE_VERSION | cut -d. -f3)
            NEW_PATCH=$((PATCH + 1))
            VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
          else
            VERSION="2.0.1"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "IS_RELEASE=false" >> $GITHUB_OUTPUT
        fi
        echo "Determined version: $VERSION"

  create-release:
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.is_release == 'true'
    permissions:
      contents: write
    
    steps:
    - name: Download binary artifacts
      uses: actions/download-artifact@v4
      with:
        name: deb-package
        path: release-artifacts
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: release-artifacts/**/*.deb
        generate_release_notes: true
        tag_name: v${{ needs.determine-version.outputs.version }}
        name: Release v${{ needs.determine-version.outputs.version }}

  deploy-ppa:
    runs-on: ubuntu-latest
    needs: [determine-version, package-source-deb]
    if: |
      (needs.determine-version.outputs.is_release == 'true') &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_ppa == 'true')
    
    steps:
    - name: Download source artifacts
      uses: actions/download-artifact@v4
      with:
        name: deb-source-package
        path: ppa-source
        
    - name: Install dput and devscripts
      run: sudo apt-get update && sudo apt-get install -y dput devscripts
    
    - name: Prepare for PPA deployment
      run: |
        cd ppa-source
        # Remove any problematic files
        rm -f *.buildinfo *.upload *.dsc.asc *.changes.asc 2>/dev/null || true
        echo "Files available for PPA deployment:"
        ls -la
        
    - name: Deploy to PPA
      env:
        PPA_URL: ${{ secrets.PPA_URL }}
        PPA_GPG_KEY: ${{ secrets.PPA_GPG_KEY }}
        PPA_GPG_PASSPHRASE: ${{ secrets.PPA_GPG_PASSPHRASE }}
        DEBEMAIL: ${{ env.DEBEMAIL }}
        DEBFULLNAME: ${{ env.DEBFULLNAME }}
      run: |
        cd ppa-source
        echo "Deploying to PPA: $PPA_URL"
        
        if [ -n "$PPA_GPG_KEY" ]; then
          echo "$PPA_GPG_KEY" | gpg --import --batch --yes
          # Get the key fingerprint
          KEY_FINGERPRINT=$(gpg --list-secret-keys --with-colons --fingerprint | grep fpr | head -1 | cut -d: -f10)
          echo "Using GPG key fingerprint: $KEY_FINGERPRINT"
          
          # Sign the changes file
          CHANGES_FILE=$(ls *.changes | head -1)
          if [ -f "$CHANGES_FILE" ]; then
            echo "Signing $CHANGES_FILE"
            debsign -k "$KEY_FINGERPRINT" "$CHANGES_FILE"
          else
            echo "ERROR: No changes file found for signing!"
            exit 1
          fi
        else
          echo "No GPG key provided, skipping signing"
        fi
        
        # Upload to PPA
        CHANGES_FILE=$(ls *.changes | head -1)
        if [ -f "$CHANGES_FILE" ]; then
          echo "Uploading $CHANGES_FILE to PPA"
          dput "$PPA_URL" "$CHANGES_FILE"
        else
          echo "ERROR: No changes file found for upload!"
          ls -la
          exit 1
        fi